#pragma kernel CSMain

// textures
RWTexture2D<float4> Texture;
Texture2D<float4> Source;

// matrixes
float4x4 CamToWorld;
float4x4 CamInverseProjection;
float4x4 CamToWorldL;
float4x4 CamInverseProjectionL;
float4x4 CamToWorldR;
float4x4 CamInverseProjectionR;

// variables
float Power;
int Iterations;
float Julia;
float3 C;
float Mix;
bool Alt;

// constants
static const int steps = 500;
static const float epsilon = 0.00004;

// structs
struct Ray { float3 origin; float3 direction; };

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(CamToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(CamInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(CamToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}


// mandelbulb distance estimator from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/
float2 DE(float3 p) {
    float3 z = p;
    float r, dr = 1;
	int i;

	for(i = 0; i < Iterations; i++) {
		r = length(z);

		if (r > 3) break;
        
		// convert to polar coordinates
		float theta = Alt ? asin(z.z / r) : acos(z.z / r);
		float phi = atan2(z.y, z.x);
		dr = pow(r, Power - 1.0) * Power * dr + 1.0;

		// scale and rotate the point
		float zr = pow(r, Power);
		theta = theta * Power;
		phi = phi * Power;
		
		// convert back to cartesian coordinates
		if (Alt) z = zr * float3(cos(theta) * cos(phi), cos(theta) * sin(phi), sin(theta));
		else z = zr * float3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
		z += Julia * C + (1 - Julia) * p;
	}
	
    float dst = 0.1 * log(r) * r / dr;
	return float2(dst, sin(i));
}

// cast a ray and return the result
float3 March(Ray ray) {
	float2 d = 0;
	float3 eye = ray.origin;
	
	int s = 0;
	while (s < steps) {
		d = DE(ray.origin); // calculate distance
		if (length(eye - ray.origin) > 100) s = steps; // to far away
		if (d.x < epsilon) break; // hit
		ray.origin += ray.direction * d.x; // march
		s++; // next iteration
	}
	
	return float3(1 - s / float(steps), length(eye - ray.origin), d.y);
}

// main method
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
	
	// convert into range [-1, 1]
	float w, h; Texture.GetDimensions(w, h);
	float2 uv = id.xy / float2(w, h) * 2 - 1;
	
	// create ray
	Ray ray = CreateCameraRay(uv);
	
	// render
	float3 res = March(ray);
	float a = res.x * (2 - Mix * 2) + res.z * (Mix * 2);
	Texture[id.xy] = Source[id.xy] + (float4(a, a, a, 0) * float4(0.8, 0.2, 0.2, 0));
	//Texture[id.xy] = float4(1, 1, 1, 1) * (res.x + 0.2) + float4(0.8, 0.2, 0.2, 0) * res.z;
}
